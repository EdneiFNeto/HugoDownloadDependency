<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Relatórios - Plugin SmartPOS</title>
    <link>//localhost:1313/functions/reports.html</link>
    <description>Relatórios Faz-se uso da classe ReportRequestBuilder. Informação Os dados de transações/relatórios duram no banco de dados por 90 dias.&#xA;Relatórios Consolidado Detalhado Turnos Filtros Os relatórios consolidado e detalhado podem ser gerados utilizando um intervalo customizado, ou um padrão do tipo hoje, ontem ou anteontem. Exemplos: Para gerar um relatório de intervalo fixo:&#xA;/* Hoje -&gt; */ ReportFilter(threshold = ReportThreshold.TODAY) /* Ontem -&gt; */ ReportFilter(threshold = ReportThreshold.YESTERDAY) /* Anteontem -&gt; */ ReportFilter(threshold = ReportThreshold.DAY_BEFORE_YESTERDAY) Para gerar um relatório customizado, é preciso passar os parâmetros de data e hora de início/fim, além do tipo, conforme abaixo:</description>
    <generator>Hugo</generator>
    <language>pt</language>
    <atom:link href="//localhost:1313/functions/reports/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Consolidado</title>
      <link>//localhost:1313/functions/reports/consolidated.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/functions/reports/consolidated.html</guid>
      <description>Relatório consolidado Request que recupera um relatório consolidado por tipo de pagamento e bandeira do cartão, em um intervalo de tempo pré definido. Dica Você pode imprimir a via passando o objeto retornado para o request de impressão&#xA;Parâmetros receiptType -&gt; Tipo de relatório, no caso do consolidado: ReceiptType.CONSOLIDATED_REPORT reportFilter -&gt; Filtro do relatório, utilizando a data class ReportFilter data class ReportFilter( val threshold: ReportThreshold? = null, val fromDate: DateParameters? = null, val fromTime: TimeParameters = TimeParameters(0, 0), val toDate: DateParameters? = null, val toTime: TimeParameters = TimeParameters(23, 59) ) enum class ReportThreshold { TODAY, YESTERDAY, DAY_BEFORE_YESTERDAY, CUSTOM } data class DateParameters( val day: Int, val month: Int, val year: Int ) data class TimeParameters( val hour: Int, val minute: Int ) Exemplo SmartPOSPlugin.createReportsRequestBuilder() .receiptType(ReceiptType.CONSOLIDATED_REPORT) .reportFilter(filter) .callback(object : Callback&lt;ReportResponse&gt;() { override fun onFail(error: Throwable) { // Erro processando relatório } override fun onSuccess(response: ReportResponse) { /* Relatório consolidado: */ val data = response.reportData.consolidatedReportData } }).build().run(Zoop::post) Retorno data class ConsolidatedReportData( val issueDate: String?, // Data de emissão do relatório val sellerName: String?, // Nome do seller val documentType: String?, // Tipo de documento (&#34;CPF&#34; ou &#34;CNPJ&#34;) val document: String?, // Documento val serialNumber: String?, // Número de série do terminal val fromDate: String?, // Data de início do relatório val toDate: String?, // Data final do relatório val fromTime: String?, // Hora inicial do relatório val toTime: String?, // Hora final do relatório val transactionData: List&lt;ConsolidatedReportTransactionData&gt;?, // Lista de dados de transação conforme descrito abaixo val summary: ConsolidatedReportSummary? // Resumo do relatório consolidado conforme descrito abaixo ) data class ConsolidatedReportTransactionData( val brand: String?, // Bandeira do cartão val status: String?, // Status da transação (&#34;approved&#34; ou &#34;canceled&#34;) val paymentType: Int?, // Inteiro, seguindo a enum class Option, descrito abaixo val totalValue: Int?, // Valor total de vendas dessa bandeira/tipo de pagamento/status val totalTransactions: Int? // Quantidade de transações dessa bandeira/tipo de pagamento/status ) data class ConsolidatedReportSummary( val totalApproved: Int?, // Valor total aprovado val totalCanceled: Int?, // Valor total cancelado val totalTransactionsApproved: Int?, // Quantidade total de transações aprovadas val totalTransactionsCanceled: Int? // Quantidade total de transações canceladas ) enum class Option(val code: Int) { CREDIT(0), // Crédito DEBIT(1), // Débito CREDIT_WITH_INSTALLMENTS(2), // Crédito parcelado VOUCHER(3), // Voucher PIX(4), // Pix UNKNOWN(-1) // Desconhecido }</description>
    </item>
    <item>
      <title>Detalhado</title>
      <link>//localhost:1313/functions/reports/detailed.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/functions/reports/detailed.html</guid>
      <description>Relatório detalhado Request que recupera um relatório detalhado com todas as transações, em um intervalo de tempo pré definido. Dica Você pode imprimir a via passando o objeto retornado para o request de impressão&#xA;Parâmetros receiptType -&gt; Tipo de relatório, no caso do consolidado: ReceiptType.DETAILED_REPORT reportFilter -&gt; Filtro do relatório, utilizando a data class ReportFilter data class ReportFilter( val threshold: ReportThreshold? = null, val fromDate: DateParameters? = null, val fromTime: TimeParameters = TimeParameters(0, 0), val toDate: DateParameters? = null, val toTime: TimeParameters = TimeParameters(23, 59) ) enum class ReportThreshold { TODAY, YESTERDAY, DAY_BEFORE_YESTERDAY, CUSTOM } data class DateParameters( val day: Int, val month: Int, val year: Int ) data class TimeParameters( val hour: Int, val minute: Int ) Exemplo SmartPOSPlugin.createReportsRequestBuilder() .receiptType(ReceiptType.DETAILED_REPORT) .reportFilter(filter) .callback(object : Callback&lt;ReportResponse&gt;() { override fun onFail(error: Throwable) { onErrorProcessingReport() } override fun onSuccess(response: ReportResponse) { /* Relatório detalhado: */ val data = response.reportData.detailedReportData } }).build().run(Zoop::post) Retorno data class DetailedReportData( val issueDate: String?, // Data de emissão do relatório val sellerName: String?, // Nome do seller val documentType: String?, // Tipo de documento (&#34;CPF&#34; ou &#34;CNPJ&#34;) val document: String?, // Documento val serialNumber: String?, // Número de série do terminal val fromDate: String?, // Data de início do relatório val toDate: String?, // Data final do relatório val fromTime: String?, // Hora inicial do relatório val toTime: String?, // Hora final do relatório val totalApproved: Int?, // Valor total aprovado val totalCanceled: Int?, // Valor total cancelado val approvedTransactions: List&lt;DetailedReportTransactionData&gt;?, // Lista de transações aprovadas val canceledTransactions: List&lt;DetailedReportTransactionData&gt;? // Lista de transações canceladas ) data class DetailedReportTransactionData( val paymentType: Int?, // Inteiro, seguindo a enum class Option, descrito abaixo val amount: Int?, // Valor da transação em centavos val date: String?, // Data da transação val time: String?, // Hora da transação val brand: String? // Bandeira do cartão ) enum class Option(val code: Int) { CREDIT(0), // Crédito DEBIT(1), // Débito CREDIT_WITH_INSTALLMENTS(2), // Crédito parcelado VOUCHER(3), // Voucher PIX(4), // Pix UNKNOWN(-1) // Desconhecido }</description>
    </item>
    <item>
      <title>Turnos</title>
      <link>//localhost:1313/functions/reports/shifts.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/functions/reports/shifts.html</guid>
      <description>Relatório de turnos O relatório de turnos é constituído por 3 requisições: Requisição que recupera um relatório do turno atual, ou, um turno previamente fechado. Requisição para fechar o turno, que recebe uma estrutura recuperada no request anterior. Requisição para recuperar uma lista com todos os turnos fechados anteriormente. Informação Caso não exista um turno fechado, é listado todas as transações do dispositivo desde a primeira transação. Caso exista um turno previamente fechado, o turno subsequente é listado a partir da data/hora do último turno.</description>
    </item>
  </channel>
</rss>